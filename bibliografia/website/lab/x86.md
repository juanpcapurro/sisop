# x86: assembler y call conventions

La entrega se realiza en horario de clase del día indicado siguiendo las [instrucciones de entrega en papel](../entregas.md#papel). Se recomienda usar la siguiente estructura de _Makefile_ (ver sección [make](kern0.md#make) del [lab kern0](kern0.md)):

```make
CFLAGS := -m32 -g -std=c99 -Wall -Wextra -Wpedantic
CFLAGS += -O1 -fno-pic -fno-omit-frame-pointer -no-pie
ASFLAGS = $(CFLAGS)

ASMS := ...  # wildcard *.S
SRCS := ...  # wildcard *.c

# Como en este lab el código de cada programa reside en un
# único archivo, los wildcard transformarán prog.c o prog.S
# directamente a "prog", sin usar compilación intermedia; esto
# es, sin que make llegue a recibir prog.o como objetivo.
PROG := ...  # patsubst %.S → %
PROG += ...  # patsubst %.c → %

all: $(PROG)

clean:
	rm -f $(PROG) *.o core

.PHONY: clean all
```


## Índice
{:.no_toc}

* TOC
{:toc}

Los ejercicios marcados con ★ no son obligatorios, pero suman cada uno 1pt adicional. Asimismo, se pueden entregar —sin penalización de nota— hasta 7 días después de la fecha de entrega original.


## Llamadas a biblioteca y llamadas al sistema
{: #syscalls}

- Lecturas obligatorias[^bibliotip]

  - KERR
    - cap. **3**{:title="System Programming Concepts"}: **§1-3**
    - cap. **4**{:title="File I/O: The Universal I/O Model"}: **§1-2**

- Lecturas recomendadas

  - KERR
    - cap. **1**{:title="History and Standards"}: **§1-3**
    - cap. **2**{:title="Fundamental Concepts"}: **§1-5**
    - cap. 3: **§6(1, 3)**{:title="Portability Issues"}
{:.biblio}

[^bibliotip]: Para ayudar a la y evitar confusión por cambios entre ediciones, cada referencia numérica incluye un “tooltip” con el título del capítulo o sección.

El siguiente programa, [hello.c](hello.c), escribe un mensaje por pantalla en un sistema POSIX, y termina con estado numérico 7:

```c
#include <unistd.h>

const char msg[] = "Hello, world!\n";

int main(void) {
    write(1, msg, sizeof msg - 1);
    _exit(7);
}
```

Nótese que se usan directamente las llamadas al sistema `write(2)` y `exit(2)` en lugar de las funciones `fputs(3)` y `exit(3)` de la biblioteca estándar.

En el archivo [libc_hello.S] se encuentra una versión en assembler del mismo programa; según la convención estándar de GCC, los parámetros se pasan en orden inverso en la pila:

```nasm
.globl main
main:
        push $len
        push $msg
        push $1

        call write

        push $7
        call _exit

.data
msg:
        .ascii "Hello, world!\n"

.set len, . - msg
```

[libc_hello.S]: libc_hello.S

### Ej: x86-write
{: #ej-write}

- Lecturas obligatorias

  - KERR
    - cap. 4: **§5**{:title="4.5 Writing to a File: write()"}

  - REES
    - cap. **4**{:title="Pointers and Arrays"}
      - _Quick Review of Arrays_
      - _Pointer Notation and Arrays_

- Lecturas recomendadas

  - BRY2
    - cap **3**{:title="Machine-Level Representation of Programs"}:
    **§8**{:title="3.8 Array allocation and Access"},
    **10**{:title="3.10 Understanding Pointers"}
{:.biblio}

Sobre el código anterior, responder:

  - ¿Por qué se le resta 1 al resultado de _sizeof?_
  - ¿Funcionaría el programa si se declarase _msg_ como `const char *msg = "...";`{:.wrap}? ¿Por qué?
  - ¿Qué tipo de entidad es `sizeof`: una función, un operador, una palabra reservada?[^sizeof]
  - Explicar el efecto del operador `.` en la línea `.set len, . - msg`.

Compilar ahora _libc_hello.S_ y verificar que funciona correctamente. Explicar el propósito de cada instrucción, y cómo se corresponde con el código C original. Después:

  - Mostrar un [hex dump] de la salida del programa en assembler. Se puede obtener con el comando `od`:

        $ ./libc_hello | od -t x1 -c
        0000000 ...

  - Cambiar la directiva [`.ascii`][ascii] por [`.asciz`][asciz] y mostrar el hex dump resultante con el nuevo código. ¿Qué está ocurriendo?

  - Mostrar cómo habría que reescribir la línea `push $len` para que el código siga escribiendo el número correcto de bytes. (Nota: no cambiar la definición de _len_.)

Finalmente, como alternativa a `.set len`, también se podría usar la función `strlen(3)` para calcular la cantidad de bytes a imprimir. En C:

```c
#include <string.h>
#include <unistd.h>

const char *msg = "Hello, world!\n";

int main(void) {
    write(1, msg, strlen(msg));
    _exit(7);
}
```

Actualizar el archivo _libc_hello.S_ eliminando la definición de _len_ en favor de una llamada a  _strlen_ para calcular el tercer parámetro de la llamada a _write_. (Incluir esta modificación directamente como parte del ejercicio _x86-call_.)

[ascii]: https://sourceware.org/binutils/docs/as/Ascii.html
[asciz]: https://sourceware.org/binutils/docs/as/Asciz.html
[hex dump]: https://en.wikipedia.org/wiki/Hex_dump

[^sizeof]: La respuesta puede encontrarse, por ejemplo, en K&R §2.12.


### Ej: x86-call
{: #ej-call}

- Lecturas obligatorias

  - BRY2
    - cap. 3: **§7**{:title="3.7 Procedures"}
{:.biblio}

El comando [disassemble] de GDB permite examinar directamente las instrucciones del programa que se está depurando. Por ejemplo, con `disas main` se muestra:

```
$ gdb -q ./libc_hello
(gdb) disas main
Dump of assembler code for function main:
   0x0804843b <+0>:     push   $0xe
   0x08048440 <+5>:     push   $0x804a020
   0x08048445 <+10>:    push   $0x1
   0x08048447 <+12>:    call   0x8048320 <write@plt>
   0x0804844c <+17>:    push   $0x7
   0x0804844e <+19>:    call   0x8048300 <_exit@plt>
```

Sin argumentos, `disas` muestra las instrucciones que se ejecutarían a continuación, esto es, las instrucciones a partir del _program counter_ actual:[^gdbrun]

```
(gdb) b main
Breakpoint 1 at 0x804843b: file libc_hello.S, line 9.

(gdb) r
Starting program: ./libc_hello
Breakpoint 1, main () at libc_hello.S:9
9               push $len

(gdb) disas
Dump of assembler code for function main:
=> 0x0804843b <+0>:     push   $0xe
   0x08048440 <+5>:     push   $0x804a020
   0x08048445 <+10>:    push   $0x1
   0x08048447 <+12>:    call   0x8048320 <write@plt>
   0x0804844c <+17>:    push   $0x7
   0x0804844e <+19>:    call   0x8048300 <_exit@plt>

(gdb) p $pc
$1 = (void (*)()) 0x804843b <main>

(gdb) p/x $pc
$2 = 0x804843b

... →
```

Mostrar en una sesión de GDB cómo imprimir las mismas instrucciones usando la directiva `x $pc` y el [modificador adecuado][gdbexam]. Después, usar el comando [`stepi`][gdbstep] _(step instruction)_ para avanzar la ejecución hasta la llamada a _write_. En ese momento, mostrar los primeros cuatro valores de la pila justo antes e inmediatamente después de ejecutar la instrucción `call`, y explicar cada uno de ellos.[^gdbrepeat]

```
... →

(gdb) x/6.. $pc
=> 0x804843b <main>:    push   $0xe
   0x8048440 <main+5>:  push   $0x804a020
   0x8048445 <main+10>: push   $0x1
   0x8048447 <main+12>: call   0x8048320 <write@plt>
   0x804844c <main+17>: push   $0x7
   0x804844e <main+19>: call   0x8048300 <_exit@plt>

(gdb) display...  # Opcional
=> 0x804843b <main>:    push   $0xe

(gdb) stepi↩︎
10              push $msg
=> 0x8048440 <main+5>:  push   $0x804a020

(gdb) si↩︎
11              push $1
=> 0x8048445 <main+10>: push   $0x1

(gdb) ↩︎
14              call write
=> 0x8048447 <main+12>: call   0x8048320 <write@plt>

(gdb) x/... $sp
0x...:  ...

(gdb) si
...

(gdb) x/... $sp
0x...:  ...
```

Finalmente, sustituir la instrucción `call write` por `jmp write`, y añadir el código y preparaciones necesarias para que el programa siga funcionando (ayuda: usar una etiqueta `posicion_retorno:` dentro de _main_ para computar la dirección de retorno). Las llamadas a _strlen_ y __exit_ pueden quedar. Incluir esta última versión en la entrega.

**Ayuda adicional GDB:** `stepi` ejecuta _solamente_ la siguiente instrucción máquina; así, al realizar `stepi` sobre `call write` la ejecución salta _adentro_ del código de la función. Para ejecutar en un solo paso el resto de la función, y volver a _main_ rápidamente, se puede usar el comando [`finish`][gdbfin] de GDB. Alternativamente, si no se necesitase “entrar” en la función, se puede usar [`next`][gdbnext] para ejecutar no una instrucción, sino una _línea de código_.

[gdbcmd]: https://sourceware.org/gdb/onlinedocs/gdb/Command-Syntax.html
[gdbexam]: https://sourceware.org/gdb/onlinedocs/gdb/Memory.html
[gdbstep]: https://sourceware.org/gdb/onlinedocs/gdb/Continuing-and-Stepping.html
[gdbfin]: https://sourceware.org/gdb/onlinedocs/gdb/Continuing-and-Stepping.html#index-fin-_0028finish_0029
[gdbnext]: https://sourceware.org/gdb/onlinedocs/gdb/Continuing-and-Stepping.html#index-next
[disassemble]: https://sourceware.org/gdb/onlinedocs/gdb/Machine-Code.html

[^gdbrun]: Nótese cómo hace falta una llamada a _run_ (`r`) para comenzar la ejecución del programa bajo GDB. No ocurría así en el depurado con QEMU, donde una llamada a _continue_ resultó ser suficiente (porque para GDB el programa remoto ya aparece como en ejecución).

[^gdbrepeat]: Como se puede observar, `stepi` se puede abreviar como `si`. Además, si se presiona ENTER en el prompt de GDB sin haber escrito nada, se ejecuta [de nuevo][gdbcmd] la acción anterior.


### Ej: x86-libc
{: #ej-libc}

- Lecturas obligatorias

  - BRY2
    - cap. **7**{:title="Linking"}:
      **§6**{:title="7.6 Symbol Resolution"},
      **10**{:title="7.10 Dynamic Linking with Shared Libraries"}

- Material de ampliación

  - packagecloud.io
    - [**The Definitive Guide to Linux System Calls**][sysguide]
{:.biblio}

[sysguide]: https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/


Las llamadas a _write_ y __exit_ en los programas anteriores no son _directamente_ llamadas al sistema, sino que pasan por la biblioteca estándar de C (libc). Para cada syscall, libc proporciona un _wrapper_ que es quien realiza la verdadera invocación al sistema.

Con el comando `nm` se puede ver cómo el linker incluyó referencias a dichos wrappers tanto en la versión en C, como en la versión en assembler:

```
$ nm --undefined hello
         U __libc_start_main@@GLIBC_2.0
         U _exit@@GLIBC_2.0
         U write@@GLIBC_2.0

$ nm -u libc_hello
         U __libc_start_main@@GLIBC_2.0
         U _exit@@GLIBC_2.0
         U write@@GLIBC_2.0
```

Como se explica en la bibliografía, las llamadas al sistema no se realizan con la instrucción `call` sino mediante una “excepción controlada” o _trap_ (instrucción `int` o, en x86\_64, `syscall`). Cada sistema operativo define su propia convención de llamada, que puede variar según la arquitectura; en el caso de Linux, los argumentos no se pasan por la pila, sino mediante registros. (Ver páginas de manual [syscalls(2)][syscalls2] y [syscall(2)][syscall2].)

Así, para llamar directamente al _syscall write_ (no al wrapper de libc) se pasan los argumentos mediante los registros _%ebx_, _%ecx_ y _%edx_. En _%eax_ se escribe una constante numérica que le indica al kernel qué syscall debe realizar. Finalmente, se cede el control de la CPU al kernel mediante una instrucción `int`:

```nasm
#include <sys/syscall.h>  // SYS_write, SYS_exit

.globl main
main:
        mov $SYS_write, %eax   // %eax == syscall number
        mov $1, %ebx           // %ebx == 1st argument (fd)
        mov $msg, %ecx         // %ecx == 2nd argument (buf)
        mov $len, %edx         // %edx == 3rd argument (count)
        int $0x80

        mov $SYS_exit, %eax
        mov $7, %ebx
        int $0x80
```

Se pide:

1.  Compilar y ejecutar el archivo completo [int80_hi.S](int80_hi.S). Mostrar la salida de `nm --undefined` para este nuevo binario.

    **¿Errores de compilación?**

    La compilación no debería fallar si están [instalados](../kit.md#tools) los paquetes `gcc-multilib` y `linux-libc-dev`. No obstante, si GCC no encuentra algún archivo _include_, quizá sea necesario indicar un directorio adicional de búsqueda, que en Debian y Ubuntu es:
    {: #incpath}

        CPPFLAGS := -I/usr/include/x86_64-linux-gnu

    En otros sistemas, se puede usar el siguiente comando para determinar desde qué ruta se están incluyendo los archivos:

        $ echo "#include <asm/unistd.h>\n SYS_write = __NR_write" |
            gcc -E -P -H -xc -

        . /usr/include/x86_64-linux-gnu/asm/unistd.h
        .. /usr/include/x86_64-linux-gnu/asm/unistd_64.h

        SYS_write = 1

    Y verificar que es posible encontrar los mismos archivos combinando `-m32` con la opción `-I` adecuada (nota: el valor de `SYS_write` es distinto entre x86 y x86\_64):

        $ echo "#include <asm/unistd.h>\n SYS_write = __NR_write" |
            gcc -m32 -I... -E -P -H -xc -

        . /usr/include/x86_64-linux-gnu/asm/unistd.h
        .. /usr/include/x86_64-linux-gnu/asm/unistd_32.h

        SYS_write = 4

2.  Escribir una versión modificada _sys_strlen.S_ en la que, eliminando la [directiva] `.set len`, se calcule la longitud del mensaje (tercer parámetro para _write_) usando directamente _strlen_ (el código será muy parecido al de ejercicios anteriores).

3.  En la convención de llamadas de GCC, ciertos registros son _caller-saved_ (por ejemplo _%ecx_) y ciertos otros _callee-saved_ (por ejemplo _%ebx_). Responder:

    - ¿qué significa que un registro sea _callee-saved_ en lugar de _caller-saved_?

    - en x86 ¿de qué tipo es cada registro según la convención de llamadas de GCC?

    - al realizar un _syscall_ de manera directa con `int $0x80` ¿qué registros son _caller-saved_?

3.  Leer en [Guide to Bare Metal Programming with GCC][107gcc] la sección: _Linker options for default libraries and start files_. En el archivo _sys_strlen.S_ del punto anterior, renombrar la función `main` a `_start`, y realizar las siguientes cuatro pruebas de compilación:

      - _int80_hi.S_ con _-nodefaultlibs_, luego con _-nostartfiles_
      - _sys_strlen.S_ con _-nodefaultlibs_, luego con _-nostartfiles_

    Mostrar el resultado (compila o no) en una tabla 2 × 2, así como los errores de compilación. Responder: ¿alguno de los dos archivos compila con _-nostdlib_?

    <!--
    En vista de los resultados, explicar las diferencias entre estas tres opciones.
    -->

4.  Añadir al archivo _Makefile_ una regla que permita compilar _sys_strlen.S_ sin errores, así como cualquier otro archivo cuyo nombre empiece por _sys_:

    ```
    sys_%: sys_%.S
            $(CC) $(ASFLAGS) $(CPPFLAGS) -no... $< -o $@
    ```

5.  Mostrar la salida de `nm --undefined` para el binario _sys_strlen_, y explicar las diferencias respecto a _int80_hi_.

[107gcc]: https://cs107e.github.io/guides/gcc/
[syscall2]: http://man7.org/linux/man-pages/man2/syscall.2.html
[syscalls2]: http://man7.org/linux/man-pages/man2/syscalls.2.html


### Ej: x86-ret
{: #ej-ret}

- Lecturas recomendadas

  - BRY2
    - cap. 3: **§11**{:title="3.11 Using the GDB Debugger"}
{:.biblio}

Un _main_ estándar devuelve `int`, y comúnmente se usa `return`, no _exit_, para devolver un código de error. Los “start files” de libc y su definición de `_start` se encargan de propagar ese valor de retorno al _syscall exit_.

Se pide ahora modificar _int80_hi.S_ para que, en lugar de invocar a a __exit()_, la ejecución finalize sencillamente con una instrucción `ret`. ¿Cómo se pasa en este caso el valor de retorno?

Para que `ret` funcione, _%esp_ debe volver a su valor original (el que tenía al entrar en la función). En los casos más sencillos, basta con asegurar que se realizan tantos `pop` como `push`.

Se pide también escribir un nuevo programa, _libc_puts.S_, que use una instrucción `ret` en lugar de una llamada a __exit_. Al contrario que _int80_hi.S_, este programa sí modifica la pila. Para simplificar la tarea, _libc_puts.S_ puede usar `puts(3)` en lugar de `write(2)`:

```c
// Versión C de libc_puts.S

#include <stdio.h>

int main(void) {
    puts("Hello, world!");
    return 7;
}
```

#### libc y exit

Se puede depurar _libc_puts_ con GDB para mostrar que, efectivamente, libc propaga el valor de retorno de _main_ a la llamada a _exit_ que termina el programa.

Se pide mostrar, usando un _catchpoint_, una sesión de GDB el momento en que el binario _libc_puts_ realiza la llamada a _exit_ con `int $0x80` o `sysenter`, y dónde reside dicha instrucción. Se incluye un guión de ejemplo más abajo.

Un [catchpoint] en GDB es un tipo especial de breakpoint que, en lugar de detener la ejecución en una línea o función, lo hace cuando se invoca una _categoría_ particular de función o instrucción. Se puede usar, por ejemplo, para capturar excepciones de C++ o aserciones fallidas en otros lenguajes.

En este caso, el interés residirá en detener la ejecución en el momento de la llamada al syscall _exit_. Como se explica en la documentación de [`catch syscall`][gdbsyscall], este comando recibe simplemente el nombre de la llamada al sistema, pudiéndose usar auto-completado.

En el momento en que se llegue a la condición de corte y se detenga la ejecución, se debe mostrar el código colindante con `disas` y los [marcos de ejecución][frames] mediante el comando [`backtrace`][backtrace] de GDB.

Finalmente se indicará, para cada función en el _backtrace_, en qué archivo o
biblioteca se aloja, esto es, la correspondencia entre las funciones del backtrace, las posiciones de memoria donde reside el código de cada función y los archivos donde se aloja el código.

Muchas de estas funciones residen en bibliotecas cargadas de dinámicamente en tiempo de ejecución. GDB puede informar de qué bibliotecas usó el mediante el  comando `info shared`.

Ayuda:

  - es posible que libc no llame a `exit(2)`, sino a `exit_group(2)`, por lo que se recomienda establecer un catchpoint para ambas syscalls.

  - las direcciones de memoria del comando `bt` corresponden a la dirección de retorno de la llamada en curso; para obtener la dirección donde reside el comienzo de la función, se puede usar `print nombre_fun`.

  - se puede abreviar `catch syscall` con `cat sys`.

Guión de ejemplo:

```
$ gdb -q ./libc_puts
(gdb) catch syscall ...
Catchpoint 1 ...

(gdb) r
Starting program: ...
...
Catchpoint 1 (call to syscall ...) ... in ...

(gdb) disas
Dump of assembler code for function ...
   0xf7...
   0xf7...
=> 0xf7...
   0xf7...
   0xf7...
   0xf7...
End of assembler dump.

(gdb) bt
#0  0xf7... in ... () from ...
...

(gdb) info shared
From | To | Syms Read | Shared Object Library
...
```

[frames]: https://sourceware.org/gdb/onlinedocs/gdb/Frames.html
[backtrace]: https://sourceware.org/gdb/onlinedocs/gdb/Backtrace.html
[catchpoint]: https://sourceware.org/gdb/onlinedocs/gdb/Set-Catchpoints.html
[gdbsyscall]: https://sourceware.org/gdb/onlinedocs/gdb/Set-Catchpoints.html#index-catch-syscall


### Ej: x86-watch ★
{: #ej-watch}

Un método más rudimentario para detectar la llegada a un syscall sin `catch syscall` sería el comando [`watch`][watch] de GDB, que vigila un registro o posición de memoria hasta que toma un cierto valor. Así, se podría detener la ejecución cuando _%eax_ u otros registros indiquen que se está por llamar a _exit_.

Se pide un guión de GDB similar al del ejercicio anterior, usando la funcionalidad _watch_ en lugar de _catch_.

Guía:

  - usar _watch_ contra el registro que aloje el _argumento_ de la llamada al sistema _exit_.

  - cambiar en el código el valor de retorno a algo con menos chances de provocar falsos positivos (por ejemplo, `return 66` o `return 0x42` en lugar de `return 7`).

  - para afinar la búsqueda, se puede vigilar también el valor de _%eax_, que tomará el valor de la constante `SYS_exit` justo antes de la instrucción `int`. Así, en lugar de:

        (gdb) watch $e.. == 0x42

    usar:

        (gdb) watch $e.. == 0x42 && $eax == ...

  - como ya se explicó, es posible que libc no llame a `exit(2)`, sino a `exit_group(2)`. Encontrar también el valor de `SYS_exit_group`, y combinar las condiciones usando `||`.

    Verificar además que los prototipos de ambas funciones son compatibles y responder: ¿cómo cambiaría la expresión booleana si —hipotéticamente— _exit_group()_ tomara el valor de salida como segundo parámetro?

  - el comando _watch_ funciona una vez arrancado el programa (`b main; r` o, lo que es lo mismo, [`start`][gdbstart]), de lo contrario quizá GDB diga “No registers”.

Finalmente, incluir de nuevo la salida del comando `info shared` y compararla con la información de regiones de memoria que Linux proporciona vía [procfs]. Así, sin cerrar aún GDB, incluir la salida de:

    $ cat /proc/`pidof libc_puts`/maps

y revisar si las bibliotecas indicadas por GDB corresponden a las ubicaciones indicadas por el kernel.

Guión de ejemplo:

```
$ gdb -q ./libc_puts
(gdb) start
Temporary breakpoint 1 at 0x80...: file libc_puts.S, line 3.

(gdb) watch ...
Watchpoint 2: ...

(gdb) c
Continuing.
Hello, world!

Watchpoint 2: ...

Old value = 0
New value = 1
0xf7... in ... () from ...

(gdb) p $eax
$1 = ...

(gdb) p $e..
$2 = 66

(gdb) disas
Dump of assembler code for function ...
   0xf7...
   0xf7...
=> 0xf7...
   0xf7...
   0xf7...
   0xf7...
End of assembler dump.

(gdb) bt
#0  0xf7... in ... () from ...
...

(gdb) info shared
From | To | Syms Read | Shared Object Library
...
```

[watch]: https://sourceware.org/gdb/onlinedocs/gdb/Set-Watchpoints.html
[gdbstart]: https://sourceware.org/gdb/onlinedocs/gdb/Starting.html
[procfs]: https://en.wikipedia.org/wiki/Procfs

[^asmguide]: De ser necesario, revisar brevemente la sección _Calling Convention_ en el [x86 Assembly Guide](http://flint.cs.yale.edu/cs421/papers/x86-asm/asm.html) de _yale.edu_.


## Stack frames y calling conventions
{: #stackframes}

En el código visto hasta ahora, se han invocado varias funciones pasando sus argumentos por la pila, pero no se ha implementado ninguna función con parámetros. Obviamente, es en la pila donde una función buscará los valores de sus parámetros.

La búsqueda de parámetros en la pila se puede ver afectada por el uso de la misma, esto es: un argumento que esté alojado en `4(%esp)` al entrar en la función, estará en `8(%esp)` si el propio código invoca a una instrucción `push`.

Para ello, se suele usar el registro _%ebp_ como “frame pointer”, guardando el valor original del registro _%esp_ de manera que las referencias a los argumentos vía _%ebp_ no varíen a lo largo de la función:

```nasm
func:
    // Al entrar, el primer argumento está en 4(%esp)

    push %ebp
    movl %esp, %ebp

    // Ahora el primer argumento está en 8(%ebp), 8(%esp)

    push $len
    push $msg

    // El primer argumento sigue en 8(%ebp), pero 16(%esp)
    ...

    // Se debe restaurar %esp y %ebp antes de "ret"
    movl %ebp, %esp
    popl %ebp

    ret
```

A menudo, el código generado por GCC no usa _%ebp_, pues desde el compilador resulta más fácil llevar la cuenta de la ubicación de los argumentos aun si cambia el valor de _%esp_ (pues el propio compilador controla cuándo lo cambia). Se puede forzar el uso de frame pointers con la opción `-fno-omit-frame-pointer`.


### Ej: x86-ebp
{: #ej-ebp}

Podemos comparar el assembler escrito a mano de _libc_hello.S_ con el assembler generado por GCC a partir de C (usando la opción `-fno-omit-frame-pointer`). El comando `objdump -S hello` mostraría el código de programa completo, pero se puede invocar a GDB en modo no interactivo para obtener el código de una sola función:

```
$ gdb -batch -ex 'disas/s main' ./hello
5       int main(void) {
   ...
   0x08048445 <+10>:    push   %ebp
   0x08048446 <+11>:    mov    %esp,%ebp
   ...

6           write(1, msg, sizeof msg - 1);
   0x0804844c <+17>:    push   $0xe
   0x0804844e <+19>:    push   $0x80484f0
   0x08048453 <+24>:    push   $0x1
   0x08048455 <+26>:    call   0x8048320 <write@plt>

7           _exit(3);
   0x0804845a <+31>:    movl   $0x7,(%esp)
   0x08048461 <+38>:    call   0x8048300 <_exit@plt>
End of assembler dump.
```

Mientras que el código resultante de compilar [libc_hello.S] es, simplemente:

```
$ gdb -batch -ex 'disas main' libc_hello
Dump of assembler code for function main:
   0x0804843b <+0>:     push   $0xe
   0x08048440 <+5>:     push   $0x804a020
   0x08048445 <+10>:    push   $0x1
   0x08048447 <+12>:    call   0x8048320 <write@plt>
   0x0804844c <+17>:    push   $0x7
   0x0804844e <+19>:    call   0x8048300 <_exit@plt>
```

Ambos son bien similares, pero tiene algunas diferencias:

1.  ¿Qué valor sobreescribió GCC cuando usó `mov $7, (%esp)` en lugar de `push $7` para la llamada a __exit_? ¿Tiene esto alguna consecuencia?

2.  La versión C no restaura el valor original de los registros _%esp_ y _%ebp_. Cambiar la llamada a `_exit(7)` por `return 7`, y mostrar en qué cambia el código generado. ¿Se restaura ahora el valor original de _%ebp_?

4.  Crear un archivo llamado _exit.c_ con la siguiente función:

    ```c
    #include <unistd.h>

    void my_exit(int status) {
        _exit(status);
    }
    ```

    y usar en _hello.c_ `my_exit(7)`:

    ```c
    extern void my_exit(int status);

    int main(void) {
        // ...
        my_exit(7);
    }
    ```

    ¿Qué ocurre con _%ebp_?

5.  Cambiar la declaración de _my_hello_ a:

    ```c
    extern void __attribute__((noreturn)) my_exit(int status);
    ```

    y verificar qué ocurre con _%ebp_, relacionándolo con el significado del atributo [noreturn].

[noreturn]: https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html


### Ej: x86-errno
{: #ej-errno}

- Lectura obligatoria:

  - BRY2
    - cap. 8: **§3**{:title="8.3 Syscam Call Error Handling"}

  - KERR
    - cap. 3: **§4**{:title="3.4 Handling Errors from System Calls and Library Functions"}
{:.biblio}

Compilar y ejecutar el siguiente programa; mostrar qué se imprime por pantalla, así como el valor de retorno en el intérprete de comandos (`echo $?`).[^incflag] Explicar también qué es la variable [`errno`][errno], y el funcionamiento de la función [`perror(3)`][perror].

```c
#include <errno.h>
#include <stdio.h>   // perror(3)
#include <unistd.h>  // write(2)

const char msg[] = "Escribiendo a nadie\n";

int main(void) {
    ssize_t ret = write(17, msg, sizeof msg - 1);

    if (ret == -1)
        perror("Falló write");

    return (ret >= 0) ? 0 : errno;
}
```

Se pedirá ahora escribir en un archivo _write2.S_ una función `write2` que actúe de “wrapper” sobre la verdadera llamada al sistema, esto es, que haga lo mismo que el propio wrapper de libc. Antes, descargar los archivos [perror.c] y [write2.S] y compilarlos con este fragmento en el archivo _Makefile:_

```make
# ...
PROG += perror2

all: $(PROG)

# ...

perror2: perror.c write2.S
	$(CC) $(CFLAGS) $(CPPFLAGS) -DUSE_WRITE2 $^ -o $@
```

Esta versión de _perror.c_ permite compilar bien contra el wrapper de libc, bien contra el wrapper que se definirá en _write2.S_. Correr los siguientes comandos y mostrar toda su salida:

```
$ make clean perror perror2 write2
...
$ ./perror; echo $?
...
$ ./perror2; echo $?
...
$ ./write2; echo $?
...
```

Estudiar el código de [perror.c] y [write2.S] y explicar cómo funciona la compilación condicional; explicar, en particular:

  - qué hace `-DUSE_WRITE2`
  - qué efecto tiene la instrucción `xor` en _write2.S_
  - qué imprime el programa `perror2`, y por qué
  - qué significa el atributo _cdecl_ asignado a `write2`.[^wpcc]
  - por qué ocurre un error al recompilar (`make clean all`) si se elimina la definición de `main` en _write2.S_

Finalmente, implementar en _write2.S_ el wrapper `write2` para la verdadera llamada al sistema. Este wrapper, al igual que el de libc:

  - recibe sus tres parámetros por la pila
  - invoca al syscall apropiado usando `SYS_write` e `int $0x80`
  - si la syscall indica éxito, devuelve el número de bytes escritos
  - en caso contrario, devuelve -1, guardando antes el código de error en la variable global `errno`.[^syserrno]

Verificar que con esta implementación, `perror2` se comporta igual que `perror` (incluyendo el caso de escribir a salida estándar).

Responder:

  - ¿qué registros debe preservar _write2_, según la call convention _cdecl?_
  - ¿cómo debería cambiar el código de _write2_ si se declarase con atributo _stdcall?_

Ayuda:

  - Realizar el preludio (`push %ebp; mov %esp, %ebp`{:.wrap}) _antes_ de guardar los “callee-saved registers”.

  - en sistemas POSIX modernos como GNU, `errno` ya no suele ser una variable global sino una macro que invoca a una función para obtener la dirección de memoria de _errno_; el nombre de la función se puede determinar expandiendo la macro expandiendo, por ejemplo, `errno = -1`:[^errnotl]

        $ gcc -imacros errno.h -E -P -xc - <<< "errno = -1;"
        (*__errno_location ()) = -1;

    Por tanto, para escribir en `errno` de manera que el valor se propague a C, se deberá obtener la posición de memoria que corresponde con `call __errno_location`. El prototipo de la función se puede observar usando `-include` en lugar de `-imacros` en el comando anterior:

        $ gcc -include errno.h -E -P -xc - <<< ""
        extern int *__errno_location (void);

[errno]: http://man7.org/linux/man-pages/man3/errno.3.html
[perror]: http://man7.org/linux/man-pages/man3/perror.3.html

[perror.c]: perror.c
[write2.S]: write2.S

[^incflag]: Si el programa no compila, revisar la información sobre la opción `-I` en el ejercicio [x86-libc](#incpath).

[^syserrno]: Linux combina en _%eax_ el valor de retorno (no negativo) con el número de error (negativo). En caso de error, la biblioteca estándar siempre convierte el valor de retorno a -1, y escribe el código de error (positivo) en `errno`.

[^wpcc]: Revisar la página de la wikipedia [x86 calling conventions](https://en.wikipedia.org/wiki/X86_calling_conventions) y el manual de GCC [x86 function attributes](https://gcc.gnu.org/onlinedocs/gcc/x86-Function-Attributes.html#x86-Function-Attributes).

[^errnotl]: Se define `errno` así, no como variable global sino mediante una indirección, para poder devolver distintos valores por thread, si el programa tiene más de un flujo de ejecución.


### Ej: x86-argv
{: #ej-argv}

- Lecturas obligatorias

  - REES
    - cap. 4
      - _Using a One-Dimensional Array of Pointers_

  - BRY2
    - cap. 8: **§4(5)**{:title="8.4.5 Loading and Running Programs"} (figura 8.21)
    - cap. 3:
    **§6**{:title="Control"}(**1-2**{:title="3.6.1 Condition Codes, 3.6.2 Accessing the Condition Codes})

- Lecturas recomendadas

  - REES
    - cap. 5
      - _Passing Arguments to an Application_

  - BRY2
    - cap. 3:
    §6(**3**{:title="3.6.3 Jump Instructions and Their Encodings"})
{:.biblio}

En este ejercicio se pide implementar un programa en assembler que imprima sus argumentos por pantalla, uno por línea. Se implementarán tres versiones sucesivas:

1. _sys_argv.S:_ imprime el primer argumento solamente, usando una llamada directa al sistema.

2. _libc_argv.S:_ imprime el primer argumento solamente, usando el wrapper `write(2)`.

3. _libc_argv2.S:_ imprime todos los argumentos recibidos, realizando una llamda a `puts(3)` para cada uno de ellos.

El estado de salida del programa debe ser:

  - para _sys_argv_ y _libc_argv_, la longitud en bytes del primer argumento.
  - para _sys_argv2_, el número total de argumentos.

Guía para cada versión:

  - _sys_argv_ es la versión más sencilla, ya que el _layout_ de los argumentos en memoria es más simple: _argc_ está en `(%esp)`, y el primer argumento directamente en `8(%esp)`.

    Responder: ¿qué hay en `4(%esp)`?

  - libc introduce un nivel de indirección, pues _argc_ está en `4(%esp)` pero en `8(%esp)` está la _dirección_ del arreglo de argumentos _argv_.

    Responder: ¿qué hay en `(%esp)`?

  - para el bucle de _libc_argv2_, se recomienda acceder a cada argumento con `push (%edi,%ebx,X)`, habiendo guardado en _%edi_ la dirección de _argv_, y estando en _%ebx_ el índice de _argv_ a acceder.

    Responder: ¿cuántas llamadas al sistema se producen realmente? (Se puede comprobar con `breakpoint write` e [`ignore`][gdbignore], o usando una herramienta como [`strace(1)`][strace].)[^julia]

Consideraciones:

  - en _sys_argv_ y _libc_argv_ se puede asumir que siempre se pasa al menos un argumento; no es necesario, por tanto, comprobar el valor de _argc_ en estos dos programas.

  - se puede asumir que ningún argumento termina en salto de línea; así, se puede añadir incondicionalmente uno.

  - en _libc_argv_, imprimir el salto de línea con una segunda llamada a `write(2)`. Se recomienda definir una constante `.ascii "\n"` llamada _newline_.

  - realizar, en _sys_argv_, una sola llamada a `write`; así, será necesario remplazar el `'\0'` final del argumento por `'\n'`. Se recomienda usar la notación `mov $('\n'), (%reg,P,X)`.

Ejemplos de invocación:

```
$ ./sys_argv palabra; echo $?
palabra
7

$ ./libc_argv ""; echo $?

0

$ ./libc_argv2 una palabra y otra; echo $?
una
palabra
y
otra
4

$ ./libc_argv2; echo $?
0
```

Estimación de código:

```
$ wc --lines *argv*.S
  19 sys_argv.S
  24 libc_argv.S
  26 libc_argv2.S
```

[gdbignore]: https://sourceware.org/gdb/onlinedocs/gdb/Conditions.html
[strace]: http://www.thegeekstuff.com/2011/11/strace-examples

[^julia]: Siendo el futuro, hay por supuesto tutoriales de _strace_ en forma de [fanzine](https://jvns.ca/blog/2015/04/14/strace-zine/). Blog de la autora [aquí](https://jvns.ca/).

### Ej: x86-frames
{: #ej-frames}

- Lecturas obligatorias

  - BRY2
    - cap. 7: **§4**{:title="7.4 Relocatable Object Files"}
{:.biblio}

Dada la convención de llamadas en x86, es posible saber la secuencia de llamadas anidadas que condujo al estado actual de ejecución. En particular, si la primera instrucción de cada función es:

    push %ebp

se está almacenando entonces en el stack de cada función una referencia al marco de ejecución inmediatamente anterior. De ahí, se puede obtener el punto de retorno y el _frame pointer_ anterior “saltando” hacia atrás  a modo de lista enlazada.

Responder, en términos del frame pointer _%ebp_ de una función _f:_

  - ¿dónde se encuentra (de haberlo) el primer argumento de _f?_
  - ¿dónde se encuentra la dirección a la que retorna _f_ cuando ejecute `ret`?
  - ¿dónde se encuentra el valor de _%ebp_ de la función anterior, que invocó a _f?_
  - ¿dónde se encuentra la dirección a la que retornará la función que invocó a _f?_

Se pide ahora escribir una función:

```c
void backtrace();
```

que obtenga, usando [`__builtin_frame_address(0)`][frameaddr], el _frame pointer_ actual, e imprima la secuencia de marcos anidados en el formato que se indica a continuación:

    #numfrm [FP] ADDR ( ARG1 ARG2 ARG3 )

donde para cada frame _FP_ es el _frame pointer_ (registro _%ebp_), _ADDR_ es el punto de retorno a la función, y _ARGS_ sus tres primeros argumentos.

Por ejemplo, para un programa de ejemplo _[backtrace.c](backtrace.c)_ (no olvidar compilar con `-fno-omit-frame-pointer`):

```
#1 [0xffffd3a8] 0x8048515 ( 0x2 0x8048667 0xf )
#2 [0xffffd3c8] 0x8048570 ( 0x0 0x0 0xf7ffdad8 )
#3 [0xffffd3e8] 0x804855a ( 0x1 0x1 0xf7fd3b48 )
#4 [0xffffd408] 0x804855a ( 0x2 0x0 0xf7fe3100 )
#5 [0xffffd428] 0x804855a ( 0x3 0xf7ffd920 0xffffd450 )
#6 [0xffffd448] 0x804855a ( 0x4 0xf7fae000 0xf7e07e18 )
#7 [0xffffd468] 0x804855a ( 0x5 0x2 0xf7e29880 )
#8 [0xffffd488] 0x8048582 ( 0xf7fae3dc 0xffffd4b0 0x0 )
#9 [0xffffd498] 0x804859d ( 0x1 0xf7fae000 0x0 )
```

En este ejemplo, el primer frame muestra la dirección de `my_write()` a que se retornará, y los argumentos con que fue llamada. Nótese que la propia función `backtrace()` _no_ aparece en la salida.

**Nota**: no usar la funcion `__builtin_return_address(...)`; solamente `__builtin_frame_address(0)`.

Incluir en la entrega:

1.  el código de la función _backtrace_.

2.  una sesión de GDB en la que se muestre la equivalencia entre el comando `bt` de GDB y el código implementado; en particular, se debe incluir:

    - la salida del comando `bt` al entrar en la función _backtrace_

    - la salida del programa al ejecutarse la función _backtrace_ (el número de frames y sus direcciones de retorno deberían coincidir con la salida de `bt`)

    - usando los comandos de [selección de frames][frameselect], y antes de salir de la función _backtrace_, el valor de _%ebp_ en cada marco de ejecución detectado por GDB (valores que también deberían coincidir).

Se puede usar el comando [`until`][gdbuntil] de GDB para saltar a la última línea de la función sin finalizar su ejecución. Guión de ejemplo:

```
...
Breakpoint 1, backtrace () at backtrace.c:4

(gdb) bt
#0  backtrace () at backtrace.c:4
#1  0x08048515 in my_write (fd=...
#2  0x08048570 in recurse (level=...
...

(gdb) list
...
10    for (...) {
...
13    }

(gdb) until 13
#1 [0xffffd3a8] 0x8048515 ( ...
#2 [0xffffd3c8] 0x8048570 ( ...
...

(gdb) up
...
(gdb) p/x $ebp
$1 = 0xffffd3a8

(gdb) up
...

(gdb) p/x $ebp
$2 = 0xffffd3c8

...

(gdb) up
Initial frame selected; you cannot go up.

(gdb) frame 0
(gdb) c
...
```

[frameaddr]: https://gcc.gnu.org/onlinedocs/gcc/Return-Address.html
[frameselect]: https://sourceware.org/gdb/onlinedocs/gdb/Selection.html
[gdbuntil]: https://sourceware.org/gdb/onlinedocs/gdb/Continuing-and-Stepping.html#index-run-until-specified-location


### Ej: x86-dwarf ★
{: #ej-dwarf}

Dado un _backtrace_ como el anterior, es deseable (como hace GDB) mostrar el nombre de la funciones asociadas a cada frame y, de ser posible, el archivo donde fue definida.

Con la opción `-g`, se le indica al compilador que debe incluir en el binario ELF una tabla con la correspondencia dirección → función.

Esta información se puede empotrar en distintos formatos, por ejemplo [STABS] (el formato tradicional de Unix) o el estándar más reciente [DWARF], que permite almacenar información más allá del nombre de las funciones (por ejemplo, el número, nombre y tipo de los argumentos).

GDB lee en tiempo de depurado la información DWARF empotrada en el binario, pero también es posible hacerlo tras la ejecución. El script de ejemplo [dwarftrace.py](dwarftrace.py) lee la salida de la función `backtrace()` del ejercicio anterior y sustituye las direcciones por nombre de función:[^pyelf]

```
$ make backtrace
...

$ chmod +x dwarftrace.py
$ ./backtrace | ./dwarftrace.py backtrace

#1 [0xffffd3a8] 0x8048515 in my_write (fd=2, msg=...)
#2 [0xffffd3c8] 0x8048570 in recurse (level=...)
...
#9 [0xffffd498] 0x804859d in main ()
```


Para este ejercicio opcional se pide:

1.  Leer el script, y mostrar la salida completa al ejecutarlo con el archivo _backtrace.c_ implementado en el ejercicio anterior.

2.  Implementar en el archivo [dwarfalu.py](dwarfalu.py) las función `get_location()`, que busca en las estructuras DWARF el archivo y línea donde se definió cada función. Como ayuda, se pueden consultar los [ejemplos][pyexamples] de la propia biblioteca _pyelf_.


[STABS]: https://en.wikipedia.org/wiki/Stabs
[DWARF]: https://en.wikipedia.org/wiki/DWARF
[pyelftools]: https://github.com/eliben/pyelftools
[pyexamples]: https://github.com/eliben/pyelftools/tree/master/examples

[^pyelf]: El script está escrito en Python, y para ejecutarlo se debe instalar la biblioteca adicional [pyelftools] (`apt-get install python3-pyelftools`{:.wrap}). Descargar también el archivo [dwarfalu.py](dwarfalu.py).


## Creación de stacks en el kernel
{: #kernstack}

Cuando un programa se ejecuta, normalmente es el sistema operativo quien le configura el stack de manera adecuada, esto es: reserva un espacio en memoria (a menudo 4 u 8 KiB) y apunta _%esp_ a dicha región (bien al límite inferior, bien al superior, según la dirección en que crece la pila en la arquitectura).

Un kernel, en cambio, es responsable de asignarse su propio _boot stack_ durante el proceso de arranque.

Por su parte, los programas de ususario también pueden crearse pilas adicionales, por ejemplo para ejecutar varias tareas de manera concurrente.


### Ej: kern1-stack
{: #kern1-stack}

- Lecturas obligatorias

  - BRY2
    - cap. 3: §6(**6**{:title="Conditional Move Instructions"})
{:.biblio}

La manera estándar de configurar la pila de arranque del sistema operativo es reservar espacio en el propio binario, esto es: un arreglo en memoria del tamaño deseado. Puede declararse en un archivo C:

```c
unsigned char kstack[8192];
```

o assembler:

```nasm
.data
kstack:
    .space 8192
```

Normalmente, en x86 se alinea el stack de los procesos de ususario a 16 o 32 bits. Sin embargo, por razones relacionadas —como se verá— con memoria virtual, el stack del kernel se suele alinear 4 KiB:

  - Explicar: ¿qué significa “estar alineado”?

  - Mostrar la sintaxis de C/GCC para alinear a 32 bits el arreglo _kstack_ anterior.

  - ¿A qué valor se está inicializando _kstack_? ¿Varía entre la versión C y la versión ASM? (Leer la documentación de _as_ sobre la directiva [`.space`][space].)

  - Explicar la diferencia entre las directivas [`.align`][align] y [`.p2align`][p2align] de _as_, y mostrar cómo alinear el stack del kernel a 4 KiB usando cada una de ellas.

Otra posibilidad para definir el stack del kernel es hacerlo en alguna otra región de memoria, separada de la imagen del kernel. Así, si se sobrepasara el espacio reservado, se evitaría sobreescribir lo que hubiera al continuación (al menos hasta que se puedan introducir otras medidas de protección, como _guard pages_).

Para ello, convendrá saber la cantidad de memoria de que dispone la máquina. A partir de ahora definiremos que la función _main_ del kernel, `kmain`, reciba un _struct_ con la información Multiboot proporcionada por el gestor de arranque (ver ejercicio [kern0-gdb](kern0.md#ej-gdb); las definiciones están disponibles en el archivo [multiboot.h](multiboot.h)):

```c
#include "decls.h"
#include "multiboot.h"

void kmain(const multiboot_info_t *mbi) {
    vga_write("kern1 loading.............", 8, 0x70);
}
```

El archivo _decls.h_, por el momento, tendría:

```c
#ifndef KERN1_DECL_H
#define KERN1_DECL_H

#include <stdint.h>

// write.c (función de kern0-vga copiada no-static).
void vga_write(const char *s, int8_t linea, uint8_t color);

#endif
```

Se pide ahora escribir una nueva versión del archivo _boot.S_ en que se defina el stack de arranque, así como el “entry point” `_start` del kernel. Así, al saltar a código C, el stack ya estará debidamente configurado:

```nasm
// boot.S

#include "multiboot.h"

#define KSTACK_SIZE 8192

.align 4
multiboot:
    .long MULTIBOOT_HEADER_MAGIC
    .long 0
    .long -(MULTIBOOT_HEADER_MAGIC)

.globl _start
_start:
    // Paso 1: Configurar el stack antes de llamar a kmain.
    movl $0, %ebp
    movl ..., %esp
    push %ebp

    // Paso 2: pasar la información multiboot a kmain. Si el
    // kernel no arrancó vía Multiboot, se debe pasar NULL.
    //
    // Usar una instrucción de comparación (TEST o CMP) para
    // comparar con MULTIBOOT_BOOTLOADER_MAGIC, pero no usar
    // un salto a continuación, sino una instrucción CMOVcc
    // (copia condicional).
    // ...

    call kmain
halt:
    hlt
    jmp halt

.data
.p2align ...
kstack:
    .space KSTACK_SIZE
```

Finalmente: mostrar en una sesión de GDB los valores de _%esp_ y _%eip_ al entrar en `kmain`, así como los valores almacenados en el stack en ese momento.

[space]: https://sourceware.org/binutils/docs/as/Space.html
[align]: https://sourceware.org/binutils/docs/as/Align.html
[p2align]: https://sourceware.org/binutils/docs/as/P2align.html
[directiva]: https://sourceware.org/binutils/docs/as/Pseudo-Ops.html


### Ej: kern1-cmdline
{: #ej-cmdline}

- Lecturas obligatorias

  - REES
    - cap. **5**{:title="Pointers and Strings"}

- Lecturas recomendadas

  - BRY2
    - cap. 3: **§12**{:title="3.12 Out-of-Bounds Memory References and Buffer Overflow"}
{:.biblio}

En el arranque, el sistema operativo puede recibir parámetros, al igual que cualquier programa, “por la línea de comandos”. En el caso de un kernel, la línea de comandos es el gestor de arranque, por ejemplo _grub_. Linux permite consultar los parámetros del arranque en el archivo `/proc/cmdline`:

    $ cat /proc/cmdline
    BOOT_IMAGE=/vmlinuz-4.9.0-3-amd64 root=/dev/sda2 ro

En QEMU, se pueden agregar parámetros al kernel mediante la opción `-append`. Si se añade una variable adicional a las [reglas de QEMU](kern0.md#make-qemu) propuestas en el lab anterior:

```make
KERN ?= kern1
BOOT := -kernel $(KERN) $(QEMU_EXTRA)
```

se puede especificar la opción directamente al invocar _make:_

    $ make qemu QEMU_EXTRA="-append 'param1=hola param2=adios'"

Ahora que `kmain` recibe un `struct multiboot_info`, se pide expandir _kern1.c_ para imprimir al arrancar los parámetros recibidos:

```c
#include <string.h>

void kmain(const multiboot_info_t *mbi) {
    vga_write("kern1 loading.............", 8, 0x70);

    if (/* mbi->flags indica que hay cmdline */) {
        char buf[256] = "cmdline: ";
        char *cmdline = (void *) mbi->cmdline;
        // Aquí usar strlcat() para concatenar cmdline a buf.
        // ...
        vga_write(buf, 9, 0x07);
    }
}
```

Para manejo de cadenas con _string.h_, se reusa la biblioteca estándar de [Pintos], un kernel educativo de Stanford; en particular:

  - [lib/string.h](string.h)
  - [lib/string.c](string.c)

Estos archivos deben ir en un subdirectorio _lib_, ajustando la variable `SRCS` como corresponda.

Finalmente:

  - Mostrar cómo implementar la misma concatenación, de manera correcta, usando [`strncat(3)`][strncat].[^nostrncat]

  - Explicar cómo se comporta [`strlcat(3)`][strlcat] si, erróneamente, se declarase _buf_ con tamaño 12. ¿Introduce algún error el código?

  - Compilar el siguiente programa, y explicar por qué se imprimen dos líneas distintas, en lugar de la misma dos veces:

    ```c
    #include <stdio.h>

    static void printf_sizeof_buf(char buf[256]) {
        printf("sizeof buf = %zu\n", sizeof buf);
    }

    int main(void) {
        char buf[256];
        printf("sizeof buf = %zu\n", sizeof buf);
        printf_sizeof_buf(buf);
    }
    ```

    Revisar, de ser necesario, K&R §5.3.[^linus]

[strlcat]: https://www.freebsd.org/cgi/man.cgi?query=strlcat&sektion=3
[strncat]: http://man7.org/linux/man-pages/man3/strcat.3.html
[lkmlarr]: https://lkml.org/lkml/2015/9/3/428 "“Christ, people. Learn C, instead of just stringing random characters together until it compiles.”"

[^nostrncat]: El archivo _string.c_ proporcionado no incluye una implementación de `strncat(3)`. Esta implementación alternativa se puede realizar leyendo la documentación de la función, y probándolo en un programa aparte, en espacio de usuario.

[^linus]: Es por esto que Linus Torvalds, [en su estilo característico][lkmlarr], recomienda siempre usar `char *buf` y nunca `char buf[]` en la declaración de una función.

#### Compiler includes
{: #no-host-includes}

En código del kernel no hay acceso a la biblioteca estándar de C, por lo que se debe incluir una implementación de todas las funciones que se invocan.

Para código kernel, el compilador debería manejar las directivas _include_ de la siguiente manera:

  1. nunca usar los archivos de la biblioteca estándar de C (p. ej. _string.h_ o _stdlib.h_)

  2. si se necesita, por ejemplo, `#include <string.h>`, se debe buscar en la propia biblioteca del kernel, en este caso el subdirectorio _lib_

  3. los includes estándar de C99 como _stdint.h_ o _stdbool.h_ sí deberían estar disponibles (en este caso, los proporciona el mismo compilador y no libc).

La opción `-ffreestanding` no es suficiente para conseguir este comportamiento, por lo que se necesitan ajustes adicionales en `CPPFLAGS`. A continuación se muestra cómo hacerlo en GCC y, más fácilmente, usando Clang:

  - Clang

        CPPFLAGS := -nostdlibinc -idirafter lib

  - GCC[^stdlibinc]

        CPPFLAGS := -nostdinc -idirafter lib

        GCC_PATH := /usr/lib/gcc/x86_64-linux-gnu/6 ⁽¹⁾
        CPPFLAGS += -I$(GCC_PATH)/include -I$(GCC_PATH)/include-fixed

        ⁽¹⁾ Consultar la salida de gcc --print-search-dirs.

Incluir el la entrega final los archivos _kern1.c_ y _boot.S_, y el _Makefile_ que se fue componiendo para su compilación (distinto del usado para las partes 1 y 2).

[Pintos]: http://pintos-os.org/
[nostdinc]: https://clang.llvm.org/docs/CommandGuide/clang.html#cmdoption-nostdinc
[nostdlibinc]: https://clang.llvm.org/docs/CommandGuide/clang.html#cmdoption-nostdlibinc

[^stdlibinc]: La opción [`-nostdlibinc`][nostdlibinc] de Clang  es precisamente la que se necesita para el kernel; GCC no la tiene, y [`-nostdinc`][nostdinc] implementa el punto 1 sin combinarlo con el 3.


### Ej: kern1-meminfo ★
{: #ej-meminfo}

Se desea imprimir durante el arranque la cantidad de memoria física que el sistema reportó a través de Multiboot; por ejemplo:

    $ make qemu QEMU_EXTRA="-append meminfo"
    kern1 loading.............
    cmdline: kern1 meminfo
    Physical memory: 127MiB total (639KiB base, 129920KiB extended)

Se puede cambiar la cantidad de memoria con el parámetro `-m` de QEMU:

    $ make qemu QEMU_EXTRA="-m 256"
    Physical memory: 255MiB total (639KiB base, 260992KiB extended)

Para imprimir un valor número en el buffer VGA se podría definir en _write.c_ una función con un prototipo similar a:

```c
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

// Escribe en ‘s’ el valor de ‘val’ en base 10 si su anchura
// es menor que ‘bufsize’. En ese caso devuelve true, caso de
// no haber espacio suficiente no hace nada y devuelve false.
bool fmt_int(uint64_t val, char *s, size_t bufsize);
```

Así, en _kmain_ se puede invocar a _fmt_int_ sobre un buffer temporal, y usar _strlcat_ para componer todas las partes:

```c
char mem[256] = "Physical memory: ";
char tmp[64] = "";

if (fmt_int(NNN, tmp, sizeof tmp)) {
    strlcat(mem, tmp, sizeof mem);
    strlcat(mem, "MiB total", sizeof mem);
}

// ...

vga_write(mem, 10, 0x07);
```

La implementación de _fmt_int_ puede comenzar por calcular la anchura del entero en decimal, y devolver _false_ si no hay espacio suficiente en el buffer recibido:

```c
static size_t int_width(uint64_t val) {
    // ...
}

bool fmt_int(uint64_t val, char *s, size_t bufsize) {
    size_t l = int_width(val);

    if (l >= bufsize)  // Pregunta: ¿por qué no "l > bufsize"?
        return false;

    s += l;
    // ...
    return true;
}
```

Ayuda adicional:

  - se puede pasar trivialmente de KiB a MiB con una operación de desplazamiento de bits, sin necesidad de división.

  - quizá la función _fmt_int_ sí necesite realizar una división y/o operación de módulo, en cuyo caso el proceso de compilación quizá falle con un error similar a:

        write.c:38: undefined reference to `__umoddi3'
        write.c:40: undefined reference to `__udivdi3'

    Este error está explicado en el documento [Guide to Bare Metal Programming with GCC][107gcc] previamente señalado, y la solución se reduce a enlazar con _libgcc_. Existen dos maneras de hacerlo:

      1.  Seguir usando directamente _ld_ como enlazador, en cuyo caso hay que solicitar a gcc la ruta completa al archivo _libgcc.a_:

              LIBGCC := $(shell $(CC) $(CFLAGS) -print-libgcc-file-name)

              $(KERN): $(OBJS)
                      ld -m elf_i386 -Ttext 0x100000 $^ $(LIBGCC) -o $@

      2.  Usar el compilador de C como front-end al enlazador, que es lo que hace _make_ por omisión. En ese caso, se debe ajustar la sintaxis de las opciones, y añadir `-nostdlib`:

              LDLIBS := -lgcc
              LDFLAGS := -m32 -nostdlib -static -Wl,-Ttext=0x100000

              $(KERN): $(OBJS)
                      $(CC) $(LDFLAGS) $^ $(LDLIBS) -o $@

          (Esta es, de hecho, la regla implícita de _make_ para el enlazado.)[^build-id]

[^build-id]: Si esta versión no arranca, probar a añadir el flag `-Wl,--build-id=none`, o seguir usando _ld_ directamente.


{% include anchors.html %}
{% include footnotes.html %}
